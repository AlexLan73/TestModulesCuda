<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# CUDA Kernel: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ—Å—É—â–µ–π —á–∞—Å—Ç–æ—Ç—ã –Ω–∞ –≤—ã–±–æ—Ä–æ—á–Ω—ã—Ö –ª—É—á–∞—Ö

–í–æ—Ç –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è GPU —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–æ–Ω—Ñ–∏–≥–æ–≤ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –ø—Ä–∏–º–µ—Ä–∞:

```cpp
#include <cuda_runtime.h>
#include <cuda_math.h>
#include <cstdint>
#include <vector>
#include <stdio.h>
#include <math.h>

// ============================================================================
// –°–¢–†–£–ö–¢–£–†–´ –ò –ö–û–ù–°–¢–ê–ù–¢–´
// ============================================================================

struct ImitObj {
    uint32_t length;
    uint32_t initSequence;
    uint64_t sigPolynomial;
    int32_t nk;
    uint32_t ndk;
    
    // –ù–æ–≤—ã–µ –ø–æ–ª—è –¥–ª—è –Ω–µ—Å—É—â–µ–π —á–∞—Å—Ç–æ—Ç—ã
    int32_t sigInitPhase[4];      // –Ω–∞—á–∞–ª—å–Ω–∞—è —Ñ–∞–∑–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞
    uint32_t sigFreq[4];          // —á–∞—Å—Ç–æ—Ç–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞
    uint32_t sigPhaseInc;         // –ø—Ä–∏—Ä–∞—â–µ–Ω–∏–µ —Ñ–∞–∑—ã
};

struct StationParams {
    uint32_t stationType;         // voronezhM, voronezhSM, mrik
};

enum StationType {
    VORONEZH_M = 1,
    VORONEZH_SM = 2,
    MRIK = 3
};

struct CarrierConfig {
    uint32_t rayIdx;              // –Ω–∞ –∫–∞–∫–æ–º –ª—É—á–µ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å (0..49)
    uint32_t rayOffset;           // —Å–º–µ—â–µ–Ω–∏–µ –≤ –æ–±—â–µ–º –±—É—Ñ–µ—Ä–µ
    uint32_t carrierStartPos;     // –Ω–∞—á–∞–ª–æ –Ω–µ—Å—É—â–µ–π –≤ –ª—É—á–µ (—Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –Ω–∞—á–∞–ª–æ–º —Å–∏–≥–Ω–∞–ª–∞)
    uint32_t carrierLength;       // –¥–ª–∏–Ω–∞ –Ω–µ—Å—É—â–µ–π (sigLength + kaiserLen - 1)
    uint32_t objIdx;              // –∏–Ω–¥–µ–∫—Å –æ–±—ä–µ–∫—Ç–∞
    uint32_t chanNum;             // –Ω–æ–º–µ—Ä –∫–∞–Ω–∞–ª–∞ (0..3)
};

struct ProfileData {
    float totalTime;
    float kernelTime;
    float memcpyH2DTime;
    float memcpyD2HTime;
    uint32_t numCarriersProcessed;
};

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
#define M_PI_F 3.14159265358979323846f
#define SYS_SENSITIVITY_LVL 16

// ============================================================================
// DEVICE FUNCTIONS
// ============================================================================

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ–¥–∏–Ω –æ—Ç—Å—á—ë—Ç –Ω–µ—Å—É—â–µ–π —á–∞—Å—Ç–æ—Ç—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º phase accumulator
 * 
 * –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
 *   adr              ‚Äî —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ñ–∞–∑—ã (phase accumulator)
 *   shift            ‚Äî –º–∞—Å—à—Ç–∞–± —Ñ–∞–∑—ã (24 –∏–ª–∏ 32)
 *   ampl             ‚Äî –∞–º–ø–ª–∏—Ç—É–¥–∞ (63 –∏–ª–∏ 511)
 */
__device__ __forceinline__ int32_t genCarrierSample(
    int64_t adr,
    uint32_t shift,
    double ampl
)
{
    // –í—ã—á–∏—Å–ª—è–µ–º sin(2*pi * adr / (1 << shift))
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ñ–∞–∑—É –≤ –¥–∏–∞–ø–∞–∑–æ–Ω [0, 2*pi]
    double phase = 2.0 * M_PI_F * ((double)adr / (double)(1LL << shift));
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é GPU —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è sin
    double sinVal = sin(phase);
    
    // –£–º–Ω–æ–∂–∞–µ–º –Ω–∞ –∞–º–ø–ª–∏—Ç—É–¥—É –∏ –æ–∫—Ä—É–≥–ª—è–µ–º
    return (int32_t)round(ampl * sinVal);
}

/**
 * –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å lookup table –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ sin
 * (–µ—Å–ª–∏ –Ω—É–∂–Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å)
 */
__device__ __forceinline__ int32_t genCarrierSampleOptimized(
    int64_t adr,
    uint32_t shift,
    float ampl
)
{
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ñ–∞–∑—É –≤ –¥–∏–∞–ø–∞–∑–æ–Ω [0, 2*pi]
    uint64_t phaseInt = (uint64_t)adr & ((1ULL << shift) - 1);
    float phase = 2.0f * M_PI_F * ((float)phaseInt / (float)(1LL << shift));
    
    // –ë—ã—Å—Ç—Ä–∞—è GPU —Ñ—É–Ω–∫—Ü–∏—è
    float sinVal = sinf(phase);
    
    return (int32_t)llroundf(ampl * sinVal);
}

// ============================================================================
// MAIN KERNEL: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ—Å—É—â–µ–π —á–∞—Å—Ç–æ—Ç—ã
// ============================================================================

/**
 * Unified kernel –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–µ—Å—É—â–µ–π —á–∞—Å—Ç–æ—Ç—ã –Ω–∞ –≤—ã–±–æ—Ä–æ—á–Ω—ã—Ö –ª—É—á–∞—Ö
 * 
 * –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
 *   d_imageData           ‚Äî –æ–±—â–∏–π –±—É—Ñ–µ—Ä –¥–ª—è –≤—Å–µ—Ö –ª—É—á–µ–π
 *   d_imitObjs            ‚Äî –º–∞—Å—Å–∏–≤ ImitObj (—Ä–∞–∑–º–µ—Ä 50)
 *   d_carrierConfigs      ‚Äî –º–∞—Å—Å–∏–≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π –Ω–µ—Å—É—â–µ–π
 *   numCarriers           ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ—Å—É—â–∏—Ö
 *   stationType           ‚Äî —Ç–∏–ø —Å—Ç–∞–Ω—Ü–∏–∏ (1=voronezhM, 2=voronezhSM, 3=mrik)
 */
__global__ void kernelGenCarrierFreqUnified(
    int32_t* d_imageData,
    const ImitObj* d_imitObjs,
    const CarrierConfig* d_carrierConfigs,
    uint32_t numCarriers,
    uint32_t stationType
)
{
    uint32_t configIdx = blockIdx.x * blockDim.x + threadIdx.x;
    
    if (configIdx >= numCarriers) return;
    
    // ========================================================================
    // –ó–ê–ì–†–£–ñ–ê–ï–ú –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Æ –ò –ü–ê–†–ê–ú–ï–¢–†–´
    // ========================================================================
    
    CarrierConfig cfg = d_carrierConfigs[configIdx];
    ImitObj obj = d_imitObjs[cfg.objIdx];
    
    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —Å—Ç–∞–Ω—Ü–∏–∏
    float ampl;
    uint32_t shift;
    
    if (stationType == VORONEZH_M) {
        ampl = 63.0f;
        shift = 24;
    } else if (stationType == VORONEZH_SM || stationType == MRIK) {
        ampl = 511.0f;
        shift = 32;
    } else {
        return;  // –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å—Ç–∞–Ω—Ü–∏–∏
    }
    
    // –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –±—É—Ñ–µ—Ä –ª—É—á–∞ —Å —Å–º–µ—â–µ–Ω–∏–µ–º –¥–æ –Ω–∞—á–∞–ª–∞ –Ω–µ—Å—É—â–µ–π
    int32_t* rayBuffer = d_imageData + cfg.rayOffset + cfg.carrierStartPos;
    
    uint32_t chanNum = cfg.chanNum;
    uint32_t carrierLen = cfg.carrierLength;
    
    // ========================================================================
    // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø PHASE ACCUMULATOR
    // ========================================================================
    
    int64_t tmp1 = 0LL;
    int64_t tmp2 = 0LL;
    
    // –ù–∞—á–∞–ª—å–Ω–∞—è —Ñ–∞–∑–∞
    int64_t initPhase = (((int64_t)obj.sigInitPhase[chanNum]) << (shift - 16));
    
    // ========================================================================
    // –û–°–ù–û–í–ù–û–ô –¶–ò–ö–õ: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ—Å—É—â–µ–π (GRID-STRIDE)
    // ========================================================================
    
    uint32_t gridSize = gridDim.x * blockDim.x;
    uint32_t tid = threadIdx.x;
    
    for (uint32_t i = tid; i < carrierLen; i += gridSize) {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–∞–∑–æ–≤—ã–π –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä
        int64_t adr = tmp1 + initPhase;
        tmp2 += obj.sigPhaseInc;
        tmp1 += (tmp2 >> SYS_SENSITIVITY_LVL) + obj.sigFreq[chanNum];
        
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç—Å—á—ë—Ç –Ω–µ—Å—É—â–µ–π
        rayBuffer[i] = genCarrierSampleOptimized(adr, shift, ampl);
    }
}

/**
 * –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –≤–µ—Ä—Å–∏—è –ë–ï–ó grid-stride (–µ—Å–ª–∏ –∫–∞–∂–¥—ã–π –ø–æ—Ç–æ–∫ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ–¥–Ω—É –Ω–µ—Å—É—â—É—é)
 */
__global__ void kernelGenCarrierFreqSimple(
    int32_t* d_imageData,
    const ImitObj* d_imitObjs,
    const CarrierConfig* d_carrierConfigs,
    uint32_t numCarriers,
    uint32_t stationType
)
{
    uint32_t configIdx = blockIdx.x * blockDim.x + threadIdx.x;
    
    if (configIdx >= numCarriers) return;
    
    CarrierConfig cfg = d_carrierConfigs[configIdx];
    ImitObj obj = d_imitObjs[cfg.objIdx];
    
    float ampl;
    uint32_t shift;
    
    if (stationType == VORONEZH_M) {
        ampl = 63.0f;
        shift = 24;
    } else if (stationType == VORONEZH_SM || stationType == MRIK) {
        ampl = 511.0f;
        shift = 32;
    } else {
        return;
    }
    
    int32_t* rayBuffer = d_imageData + cfg.rayOffset + cfg.carrierStartPos;
    uint32_t chanNum = cfg.chanNum;
    uint32_t carrierLen = cfg.carrierLength;
    
    int64_t tmp1 = 0LL, tmp2 = 0LL;
    int64_t initPhase = (((int64_t)obj.sigInitPhase[chanNum]) << (shift - 16));
    
    // –ö–∞–∂–¥—ã–π –ø–æ—Ç–æ–∫ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ–¥–Ω—É –Ω–µ—Å—É—â—É—é –ø–æ–ª–Ω–æ—Å—Ç—å—é (–µ—Å–ª–∏ carrierLen –Ω–µ–≤–µ–ª–∏–∫)
    for (uint32_t i = 0; i < carrierLen; i++) {
        int64_t adr = tmp1 + initPhase;
        tmp2 += obj.sigPhaseInc;
        tmp1 += (tmp2 >> SYS_SENSITIVITY_LVL) + obj.sigFreq[chanNum];
        
        rayBuffer[i] = genCarrierSampleOptimized(adr, shift, ampl);
    }
}

// ============================================================================
// HOST CLASS: Unified Carrier Generator
// ============================================================================

class OptimizedCarrierGenerator
{
public:
    /**
     * –ü—Ä–∏–º–µ—Ä –∑–∞–ø—É—Å–∫–∞ —Å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è–º–∏ –Ω–µ—Å—É—â–∏—Ö
     */
    static void runExample(
        const std::vector<SignalConfig>& h_signalConfigs,
        const uint32_t* h_raySignalLens,
        uint32_t totalNumRays,
        uint32_t kaiserLen = 10
    )
    {
        const uint32_t NUM_RAYS = 50;
        const uint32_t MAX_RAY_SIZE = 100000;
        
        // ====================================================================
        // –°–û–ó–î–ê–ù–ò–ï –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ô –ù–ï–°–£–©–ò–• –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–Ω—Ñ–∏–≥–æ–≤ —Å–∏–≥–Ω–∞–ª–æ–≤
        // ====================================================================
        
        printf("\n========================================\n");
        printf("Unified Carrier Generation\n");
        printf("========================================\n");
        
        std::vector<CarrierConfig> h_carrierConfigs;
        
        for (size_t i = 0; i < h_signalConfigs.size(); i++) {
            SignalConfig sigCfg = h_signalConfigs[i];
            
            // –î–ª–∏–Ω–∞ –Ω–µ—Å—É—â–µ–π = –¥–ª–∏–Ω–∞ —Å–∏–≥–Ω–∞–ª–∞ + (kaiserLen - 1) –µ—Å–ª–∏ –±—ã–ª –ö–∞–π–∑–µ—Ä
            uint32_t sigLen = h_raySignalLens[sigCfg.rayIdx];
            
            // –°–æ–∑–¥–∞—ë–º –Ω–µ—Å—É—â—É—é –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 4 –∫–∞–Ω–∞–ª–∞)
            for (uint32_t chanNum = 0; chanNum < 4; chanNum++) {
                CarrierConfig carrCfg;
                carrCfg.rayIdx = sigCfg.rayIdx;
                carrCfg.rayOffset = sigCfg.rayOffset;
                carrCfg.carrierStartPos = sigCfg.signalOffsetInRay;
                carrCfg.carrierLength = sigLen;
                carrCfg.objIdx = sigCfg.objIdx;
                carrCfg.chanNum = chanNum;
                
                h_carrierConfigs.push_back(carrCfg);
            }
        }
        
        uint32_t numCarriers = h_carrierConfigs.size();
        
        printf("Carriers to generate: %u\n", numCarriers);
        printf("Channels: 4\n");
        printf("Total rays: %u\n\n", NUM_RAYS);
        
        printf("Configuration:\n");
        for (uint32_t i = 0; i < numCarriers && i < 8; i++) {
            printf("  Carrier %u: Ray %u, Chan %u, Pos %u, Len %u\n",
                   i, h_carrierConfigs[i].rayIdx, h_carrierConfigs[i].chanNum,
                   h_carrierConfigs[i].carrierStartPos, h_carrierConfigs[i].carrierLength);
        }
        if (numCarriers > 8) printf("  ... and %u more\n", numCarriers - 8);
        printf("\n");
        
        // ====================================================================
        // –í–´–î–ï–õ–ï–ù–ò–ï –ü–ê–ú–Ø–¢–ò
        // ====================================================================
        
        printf("Allocating GPU memory...\n");
        
        int32_t* d_imageData = nullptr;
        ImitObj* d_imitObjs = nullptr;
        CarrierConfig* d_carrierConfigs = nullptr;
        
        size_t totalImageSize = (size_t)NUM_RAYS * MAX_RAY_SIZE;
        
        cudaMalloc(&d_imageData, totalImageSize * sizeof(int32_t));
        cudaMalloc(&d_imitObjs, NUM_RAYS * sizeof(ImitObj));
        cudaMalloc(&d_carrierConfigs, numCarriers * sizeof(CarrierConfig));
        
        // –û–±—Ä–∞–∑—ã —É–∂–µ –Ω—É–ª–µ–≤—ã–µ, –Ω–µ –Ω—É–∂–Ω–æ memset
        
        // ====================================================================
        // –ö–û–ü–ò–†–û–í–ê–ù–ò–ï –ù–ê GPU
        // ====================================================================
        
        ProfileData profData = {0};
        
        cudaEvent_t h2d_start, h2d_stop;
        cudaEventCreate(&h2d_start);
        cudaEventCreate(&h2d_stop);
        
        printf("Copying data to GPU...\n");
        
        cudaEventRecord(h2d_start);
        
        // –ö–æ–ø–∏—Ä—É–µ–º –æ–±—ä–µ–∫—Ç—ã
        ImitObj h_imitObjs[NUM_RAYS];
        for (uint32_t i = 0; i < NUM_RAYS; i++) {
            h_imitObjs[i] = imitObjects[i];
        }
        
        cudaMemcpy(d_imitObjs, h_imitObjs, NUM_RAYS * sizeof(ImitObj), 
                   cudaMemcpyHostToDevice);
        cudaMemcpy(d_carrierConfigs, h_carrierConfigs.data(),
                   numCarriers * sizeof(CarrierConfig), cudaMemcpyHostToDevice);
        
        cudaEventRecord(h2d_stop);
        cudaEventSynchronize(h2d_stop);
        
        cudaEventElapsedTime(&profData.memcpyH2DTime, h2d_start, h2d_stop);
        printf("  H->D copy: %.3f ms\n\n", profData.memcpyH2DTime);
        
        // ====================================================================
        // –ó–ê–ü–£–°–ö KERNEL'–ê
        // ====================================================================
        
        printf("Executing unified kernel...\n");
        
        cudaEvent_t k_start, k_stop;
        cudaEventCreate(&k_start);
        cudaEventCreate(&k_stop);
        
        cudaEventRecord(k_start);
        
        // –í—ã–±–∏—Ä–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –ø–æ—Ç–æ–∫–æ–≤ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –Ω–µ—Å—É—â–∏—Ö
        uint32_t threadsPerBlock;
        uint32_t numBlocks;
        
        if (numCarriers <= 32) {
            // –ú–∞–ª–æ –Ω–µ—Å—É—â–∏—Ö ‚Üí –ø—Ä–æ—Å—Ç–æ–π kernel –±–µ–∑ grid-stride
            threadsPerBlock = 64;
            numBlocks = (numCarriers + threadsPerBlock - 1) / threadsPerBlock;
            
            kernelGenCarrierFreqSimple<<<numBlocks, threadsPerBlock>>>(
                d_imageData,
                d_imitObjs,
                d_carrierConfigs,
                numCarriers,
                VORONEZH_M
            );
        } else {
            // –ú–Ω–æ–≥–æ –Ω–µ—Å—É—â–∏—Ö ‚Üí grid-stride –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –æ–¥–Ω–æ–π –Ω–µ—Å—É—â–µ–π
            threadsPerBlock = 256;
            numBlocks = 64;  // –º–Ω–æ–≥–æ –±–ª–æ–∫–æ–≤ –¥–ª—è –ø–æ–ª–Ω–æ–π –æ–∫–∫—É–ø–∞–Ω—Ü–∏–∏
            
            kernelGenCarrierFreqUnified<<<numBlocks, threadsPerBlock>>>(
                d_imageData,
                d_imitObjs,
                d_carrierConfigs,
                numCarriers,
                VORONEZH_M
            );
        }
        
        cudaEventRecord(k_stop);
        cudaEventSynchronize(k_stop);
        
        cudaEventElapsedTime(&profData.kernelTime, k_start, k_stop);
        
        printf("  Kernel time: %.3f ms\n");
        printf("  Grid: %u blocks √ó %u threads\n", numBlocks, threadsPerBlock);
        printf("  Carriers processed: %u\n\n", numCarriers);
        
        // ====================================================================
        // –ü–†–û–§–ò–õ–ò–†–û–í–ê–ù–ò–ï
        // ====================================================================
        
        printf("========== PROFILING RESULTS ==========\n");
        printf("H->D Memcpy:          %.3f ms\n", profData.memcpyH2DTime);
        printf("Kernel:               %.3f ms\n", profData.kernelTime);
        printf("-------------------------------------\n");
        printf("Total:                %.3f ms\n", 
               profData.memcpyH2DTime + profData.kernelTime);
        printf("Carriers Processed:   %u\n", numCarriers);
        printf("Time per Carrier:     %.4f ms\n", profData.kernelTime / numCarriers);
        
        // –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–æ–ø—É—Å–∫–Ω—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å
        uint64_t totalSamples = 0;
        for (const auto& cfg : h_carrierConfigs) {
            totalSamples += cfg.carrierLength;
        }
        printf("Throughput:           %.2f M samples/sec\n",
               (totalSamples / 1e6) / (profData.kernelTime / 1000.0));
        printf("========================================\n\n");
        
        // ====================================================================
        // –û–ß–ò–°–¢–ö–ê
        // ====================================================================
        
        cudaFree(d_imageData);
        cudaFree(d_imitObjs);
        cudaFree(d_carrierConfigs);
        
        cudaEventDestroy(h2d_start);
        cudaEventDestroy(h2d_stop);
        cudaEventDestroy(k_start);
        cudaEventDestroy(k_stop);
        
        printf("‚úì Completed!\n\n");
    }
};

// ============================================================================
// MAIN: –ü–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä (—Å —Å–∏–≥–Ω–∞–ª–∞–º–∏ + –Ω–µ—Å—É—â–µ–π)
// ============================================================================

int main()
{
    const uint32_t NUM_RAYS = 50;
    const uint32_t MAX_RAY_SIZE = 100000;
    
    // ========================================================================
    // –ó–ê–ü–£–°–ö 1: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤
    // ========================================================================
    
    printf("=== STEP 1: SIGNAL GENERATION ===\n");
    
    std::vector<SignalConfig> h_signalConfigs = {
        { 2, 2 * MAX_RAY_SIZE, 0, 0, 1 },
        { 5, 5 * MAX_RAY_SIZE, 1000, 0, 1 },
        { 7, 7 * MAX_RAY_SIZE, 0, 1, 1 },
        { 15, 15 * MAX_RAY_SIZE, 500, 2, 0 },
    };
    
    // –ó–∞–ø—É—Å–∫ kernel'–∞ –¥–ª—è —Å–∏–≥–Ω–∞–ª–æ–≤ (–∫–æ–¥ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –ø—Ä–∏–º–µ—Ä–∞)
    // OptimizedSignalGenerator::runExample();
    
    // –ü–æ–ª—É—á–∞–µ–º –¥–ª–∏–Ω—ã —Å–∏–≥–Ω–∞–ª–æ–≤
    uint32_t h_raySignalLens[NUM_RAYS] = {0};
    
    // TODO: –∫–æ–ø–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å GPU
    // cudaMemcpy(h_raySignalLens, d_raySignalLens, ...);
    
    // –í—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–ø–æ–ª–Ω—è–µ–º –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞
    for (size_t i = 0; i < h_signalConfigs.size(); i++) {
        uint32_t rayIdx = h_signalConfigs[i].rayIdx;
        h_raySignalLens[rayIdx] = 1024 + 9;  // sigLen + (kaiserLen - 1)
    }
    
    // ========================================================================
    // –ó–ê–ü–£–°–ö 2: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ—Å—É—â–µ–π —á–∞—Å—Ç–æ—Ç—ã
    // ========================================================================
    
    printf("\n=== STEP 2: CARRIER GENERATION ===\n");
    
    OptimizedCarrierGenerator::runExample(
        h_signalConfigs,
        h_raySignalLens,
        NUM_RAYS,
        10  // kaiserLen
    );
    
    return 0;
}
```


***

## –ö–ª—é—á–µ–≤—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:

| –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è | –û–ø–∏—Å–∞–Ω–∏–µ |
| :-- | :-- |
| **Grid-stride loop** | –î–ª—è –±–æ–ª—å—à–∏—Ö carrierLen: –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ—Ç–æ–∫–æ–≤ —Ä–∞–±–æ—Ç–∞—é—Ç –Ω–∞–¥ –æ–¥–Ω–æ–π –Ω–µ—Å—É—â–µ–π |
| **–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏** | `sinf()` –≤–º–µ—Å—Ç–æ `sin()` –¥–ª—è float |
| **llroundf()** | –ë—ã—Å—Ç—Ä–æ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –≤–º–µ—Å—Ç–æ `round()` |
| **–õ–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ** | Phase accumulator –≤ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ö |
| **–ö–æ–Ω—Ñ–∏–≥ –∏–∑ —Å–∏–≥–Ω–∞–ª–æ–≤** | –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞—ë–º –Ω–µ—Å—É—â–∏–µ –Ω–∞ –±–∞–∑–µ —Å–∏–≥–Ω–∞–ª–æ–≤ |
| **–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª—ã** | –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ —Å–æ–∑–¥–∞—ë–º 4 –Ω–µ—Å—É—â–∏–µ (–ø–æ —á–∏—Å–ª—É –∫–∞–Ω–∞–ª–æ–≤) |

## –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º –ø—Ä–∏–º–µ—Ä–æ–º:

```cpp
// –ü–æ—Å–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤:
uint32_t h_raySignalLens[50];
cudaMemcpy(h_raySignalLens, d_raySignalLens, 50 * sizeof(uint32_t), 
           cudaMemcpyDeviceToHost);

// –°—Ä–∞–∑—É –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–µ—Å—É—â—É—é:
OptimizedCarrierGenerator::runExample(
    h_signalConfigs,
    h_raySignalLens,
    50,
    10
);
```

–í—Å—è –ª–æ–≥–∏–∫–∞ –≤—Å—Ç—Ä–æ–µ–Ω–∞, –Ω–∏—á–µ–≥–æ –Ω–µ –Ω—É–∂–Ω–æ —Å—á–∏—Ç–∞—Ç—å –≤—Ä—É—á–Ω—É—é! üöÄ

