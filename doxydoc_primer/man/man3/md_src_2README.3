.TH "md_src_2README" 3 "Test moduls" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md_src_2README \- Тестовые скрипты 
.PP
 Тестовые скрипты (\fCmodel-checker\&.sh\fP, \fCtest-patches\&.sh\fP) сделаны для проверок рефакторинга кода (т\&.е\&. преобразований, улучшающих структуру и/или быстродействие кода, но не меняющих его поведение), хотя могут использоваться и для обнаружения нежелательных последствий любых изменений (например, если доработка касается только МРИК, но внезапно меняется выдача модели для СМ)\&. В основе работы скриптов лежит простая идея - мы сохраняем выдачу (все срезы) прогона некого ФУ на 'заведомо правильной' базовой версии модели, и затем сравниваем сохраненную выдачу с выдачей новой версии модели\&. Очевидно, что для тщательной проверки необходимо много разнообразного ФУ (которое затрагивает все режимы работы модели); имеющееся тестовое ФУ хранится в поддереве каталогов с корнем в \fCsrc/model/testcases\fP\&. В свою очередь, ФУ разделяется по станциям - ФУ каждой станции хранится в подкаталогах \fCtestcases/MRIK\fP, \fCtestcases/VoronezhM\fP, \fCtestcases/VoronezhCM\fP, с легкими для понимания мнемоническими именами вроде \fC1fu_M_strobe_1_tipsig_1_object_8_type_interf\fP\&. Подкаталог с ФУ содержит собственно файл или файлы с ФУ (несколько файлов с сообщениями ФУ, зарегистрированными через ФПО МПК1, или файл \fCinput\&.json\fP, импортированный из GUI модели - см\&. ниже); выдача от прогона ФУ так же сохраняется в каталоге ФУ (точнее, в подкаталоге \fCbaselines\fP каталога ФУ)\&. Возможно сохранять выдачу разных вариантов модели под разными именами - т\&.е\&. фактически создавать \fIнесколько именованых эталонов\fP (baseline-ов; термины 'эталон' и 'baseline' будут использоваться как эквивалентные): это бывает полезным, например, при отработке одной версии модели в разных системах - например, выдачу от прогона модели в Debian 9 сохранять под именем \fCdebian9\fP (в \fCbaselines/debian9\fP), а выдачу от прогона в Ubuntu 16\&.04 - под именем \fCubuntu16\fP (в \fCbaselines/ubuntu16\fP)\&. Имя эталона задается через опцию \fC-n\fP, ее можно использовать и при сохранении выдачи, и при сравнении текущей выдачи с сохраненной; впрочем, имя эталона задавать не обязательно (если оно не задано, считается, что это имя - \fCdefault\fP, и данные от прогона ФУ сохраняются в подкаталоге \fCbaselines/default\fP);
.PP
Для сохранения выдачи предназначена команда \fC\&./model-checker\&.sh make-baseline\fP; она принимает в виде аргумента список ФУ (т\&.е\&. имена каталогов с ФУ); например, команда 
.PP
.nf
\&./model\-checker\&.sh make\-baseline testcases/VoronezhM/1fu_M_strobe_1_tipsig_1_object_8_type_interf

.fi
.PP
 сохранит выдачу, сгенерированную прогоном ФУ из каталога \fCtestcases/VoronezhM/1fu_M_strobe_1_tipsig_1_object_8_type_interf\fP на текущем варианте модели\&.
.PP
Команда 
.PP
.nf
\&./model\-checker\&.sh make\-baseline testcases/*/*

.fi
.PP
 сохранит выдачу всех имеющихся ФУ (в обоих случаях, выдача будет сохранена под именем \fCdefault\fP)\&.
.PP
\fBTip 1\fP: если у вас не хватает места, вы можете создавать эталоны где угодно - скопируйте \fCtestcases\fP в другой каталог и укажите файлы из этого каталога в вызове \fCmodel-checker\&.sh\fP 
.PP
.nf
cp \-rs $(pwd)/testcases /media/me/ext_hdd
\&./model\-checker\&.sh make\-baseline /media/me/ext_hdd/testcases/*/*
\&./model\-checker\&.sh check\-baseline /media/me/ext_hdd/testcases/*/*

.fi
.PP
 Весь огромный объем данных эталонов будет записан в подкаталоги \fC/media/me/ext_hdd\fP\&. Заметьте, что используется команда \fCcp -rs\fP, которая вместо настоящего копирования делает симлинки на оригинальные файлы (но создает реальное дерево каталогов); \fCcp -rs\fP необходимы 2 абсолютных имени, поэтому \fC$(pwd)/testcases\fP делает из \fCtestcases\fP абсолютное имя\&. Вместо \fCcp -rs\fP можно использовать и обычную \fCcp -r testcases /media/me/ext_hdd\fP, но тогдна файлы с ФУ будут скопированы, и их правки придется вручную переносить в рабочую копию\&.
.PP
Для сравнения выдачи текущего варианта модели с сохраненным используется команда \fC\&./model-checker\&.sh check-baseline\fP; например, команда 
.PP
.nf
\&./model\-checker\&.sh check\-baseline testcases/*/*

.fi
.PP
 сравнит выдачу всех имеющихся ФУ с ранее сохраненной (под именем \fCdefault\fP)\&.
.PP
\fBTip 2\fP: при проверке эталона во временный каталог записывается содержимое всех срезов, генерируются MD5-суммы всех записанных файлов, затем полученные MD5-суммы сравниваются с MD5-суммами файлов эталона\&. Если у вас есть (даже сравнительно небольшой - 20-30GB) быстрый носитель (SSD), можно создавать временный каталог там, это заметно ускоряет работу: 
.PP
.nf
\&./model\-checker\&.sh check\-baseline \-t /path/to/ssd testcases/*/*

.fi
.PP
.PP
\fBTip 3\fP: если у вас вообще нет места на диске, вы можете просто затарить файлы MD5-сумм существующих эталонов, растарить их куда сами захотите, и использовать получившийся 'эталон': 
.PP
.nf
cd /media/me/ext_hdd
# в текущем каталоге есть каталог testcases, содержащий один или несколько эталонов
tar cvf /tmp/baselines\&.tar $(find testcases \-name MD5SUMS)
cd /tmp
tar xvf baselines\&.tar
cd ~/work/model/src
\&./model_dumper /tmp/testcases/VoronezhCM/example

.fi
.PP
.PP
Команда 
.PP
.nf
\&./model\-checker\&.sh check\-baseline \-n mybaseline testcases/*/*

.fi
.PP
 сравнит выдачу всех имеющихся ФУ с ранее сохраненной под именем \fCmybaseline\fP\&. Обратите внимание, что в вызове обеих команд указываются имена каталогов с ФУ и (не обязательно) имена эталонов (baseline-ов); это значит, что вы можете проверять эталон для подмножества ФУ, указанного при его генерации\&.
.PP
Скрипты имеют много полезных опций и выдают подсказку по использованию при вызове без параметров\&.
.PP
Если в работе используются очереди патчей (расширение Mercurial \fCmq\fP), для проверки нескольких патчей одной командой можно использовать скрипт \fCtest-patches\&.sh\fP\&. Он последовательно накладывает указанные патчи и сравнивает выдачу модели с указанным эталоном\&.
.SS "TL;DR"
На свежесобранной модели:
.PP
.RS 4
\fCcd src/model\fP
.br
 \fC\&./model-checker\&.sh make-baseline testcases/*/example\fP 
.RE
.PP
*\&.\&.\&.вносим изменения и собираем измененную модель\&.\&.\&.*
.PP
.RS 4
\fC\&./model-checker\&.sh check-baseline testcases/*/example\fP 
.RE
.PP
.SS "Использование ФУ, сохраненного через GUI"
Для использования в тестах ФУ, сохраненного через GUI модели, его нужно импортировать, т\&.е\&. записать в поддерево \fCtestcases\fP, соответствующее станции, для которой это ФУ предназначено\&. Импорт необходим по двум причинам: во-первых, ФУ, сохраняемое через GUI модели, не является валидным JSON (у некоторых объектов есть поля с одинаковыми именами), и просто неудобен для загрузки (например, все поля имеют строковые значения); во-вторых, тестовые скрипты рассчитывают на определенную структуру каталогов, и ее нужно создать (что делается при импорте)\&. Импорт выполняется скриптом \fCtestcases/import\&.sh\fP; он должен вызываться в каталоге, соответствующем станции (например, \fCtestcases/VoronezhCM\fP)\&. Предположим, что файлы с новым ФУ (\fC*\&.json\fP) для Воронеж-СМ находятся в каталоге \fCsrc/model/testcases\fP; тогда для их импорта нужно выдать команды: 
.PP
.nf
cd testcases/VoronezhCM
\&.\&./import\&.sh \&.\&./\&.\&./*\&.json

.fi
.PP
 Эта команда создаст в каталоге \fCtestcases/VoronezhCM\fP каталоги, соответствующие именам файлов ФУ (без суффикса \fC\&.json\fP) или выдаст ошибку\&.
.PP
Собственно преобразование ФУ в валидный JSON делается скриптом \fC\fBconvert_to_json\&.py\fP\fP, например, так:
.PP
\fC\&./convert_to_json\&.py\fP \fIимя-файла-с-ФУ\fP
.PP
\fC\&./convert_to_json\&.py\fP обрабатывает 1 файл (или, если аргумент не указан, стандартный вход) и выдает результат на стандартный вывод\&. Пользоваться этим скриптом следует только тогда, когда что-то пошло не так с \fCtestcases/import\&.sh\fP\&.
.SH "OpenMP"
.PP
Распараллеливание вычислений в модели сделано с использованием OpenMP, так что доступны все возможности OpenMP по настройке производительности (см\&. например, \fCздесь\fP); пока что эксперименты показывают, что единственным параметром, настройка которого дает (небольшой) выигрыш в скорости, является \fCOMP_WAIT_POLICY\fP: 
.PP
.nf
export OMP_WAIT_POLICY=passive
\&./runLocalVersion

.fi
.PP
 
